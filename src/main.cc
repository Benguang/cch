#include <assert.h> // for assert()
#include <getopt.h> // for getopt()
#include <stdlib.h> // for abort()
#include <iostream>
#include <fstream>
#include <sstream>

using namespace std;

#include "Tokenizer.h"
#include "Parser.h"


static void writeToFile(const string& filename,
                      const string& banner,
                      const stringstream& content) {
    ofstream file(filename.c_str(), ios::binary);
    if (!banner.empty()) {
        file << banner << endl;
    }
    file << content.str();
    file.close();
}

void version() {
    cerr << "CCH - " << kRepoUrl << endl <<
        "Version: " << kBuildVersion << "" << endl;
}

int main(int argc, char** argv) {
    string cchFilename;
    string outputDirectory;
    string ccExtension = "cc", hExtension = "h";
    bool debug = false;
    bool includeBanner = true;
    bool emitLineNumbers = true;
    bool usage = false;

    static struct option long_options[] = {
        {"help", no_argument, 0, 'h'},
        {"debug", no_argument, 0, 'd'},
        {"input", required_argument, 0, 'i'},
        {"output", required_argument, 0, 'o'},
        {"version", no_argument, 0, 'v'},
        {"noBanner", no_argument, 0, 1},
        {"noLineNumbers", no_argument, 0, 2},
        {"ccExtension", required_argument, 0, 3},
        {"hExtension", required_argument, 0, 4},
        {0, 0, 0, 0}
    };

    int optindex = 0;
    for (int c = 0; (c = getopt_long(argc, argv, "hdi:o:v",
                                     long_options, &optindex)) != -1; ) {
        switch (c) {
        case 1:   includeBanner = false; break;
        case 2:   emitLineNumbers = false; break;
        case 3:   ccExtension = optarg; break;
        case 4:   hExtension = optarg; break;
        case 'd': debug = true; break;
        case 'i': cchFilename = optarg; break;
        case 'o': outputDirectory = optarg; break;
        case 'v': version(); return 1;
        case 'h':
        default:  usage = true; break;
        }
    }
    if (usage || (optind < argc) || cchFilename.empty() || outputDirectory.empty()) {
        if (optind < argc) {
            cerr << "Unrecognized arguments: ";
            for (int i = optind; i < argc; i++) {
                cerr << argv[i];
            }
            cerr << endl << endl;
        }
        if (usage) {
            version();
        }
        cerr << "Usage: " << argv[0] << " [OPTIONS] -i/--input=<file> " <<
            " -o/--output=<dir>" << endl << endl <<
            "   Required:\n"
            "      -i <file>, --input=<file> Input CCH file\n"
            "      -o <dir>, --output=<dir>  Output directory\n"
            "   Optional:\n"
            "      -d, --debug               Enable debug output\n"
            "      -h, --help                Show this help menu and exit\n"
            "      -v, --version             Show program version and exit\n"
            "      --noLineNumbers           Don't emit #line directives\n"
            "      --noBanner                Don't add CCH banner to generated files\n"
            "      --ccExtension=<ext>       Set output extension\n"
            "      --hExtension=<ext>        Set output extension \n";
        return 1;
    }

    string cch;
    {   // Populate cch with the contents of the .cch file.
        ifstream inputFile(cchFilename.c_str(), ios::in|ios::binary|ios::ate);
        if (!inputFile.good()) {
            cerr << "ERROR: failed to open input: " << cchFilename << endl;
            return 2;
        }
        cch.resize(inputFile.tellg());
        inputFile.seekg(0, ios::beg);
        inputFile.read(&cch[0], cch.size());
    }

    stringstream cc, h;
    {   // Split cch into the cc and h buffers.
        ParseContext ctx(cchFilename, &cc, &h, emitLineNumbers);
        BaseTokenizer tokenizer;
        BaseParser parser(&ctx, &tokenizer);

        WrapperParser typeChanger(parser);
        tokenizer.tokenize(cch, &typeChanger);
    }

    string basename = cchFilename;
    if (basename.find_last_of('/') != string::npos) {
        basename = basename.substr(basename.find_last_of('/') + 1);
    }
    if (outputDirectory.size() > 0
        && outputDirectory[outputDirectory.size()-1] != '/') {
        outputDirectory += "/";
    }
    string ccFilename = outputDirectory + basename + "." + ccExtension;
    string hFilename = outputDirectory + basename + "." + hExtension;
    cout << "[CCH] " << cchFilename << " split to { " <<
        hFilename << ", " << ccFilename << " }" << endl;
    if (debug) {
        cout << ".h file:" << endl << h.str() << endl <<
            ".cc file:" << endl << cc.str() << endl;
    }
    string banner;
    if (includeBanner) {
        banner = "// Generated by CCH (";
        banner += kRepoUrl;
        banner += ") ";
        banner += kBuildVersion;
    }
    writeToFile(ccFilename, banner, cc);
    writeToFile(hFilename, banner, h);
    return 0;
}
